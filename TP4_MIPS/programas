test cortocircuito 1
	prueba cortocircuito con instruccion i+1

000000 sssss ttttt ddddd ----- 100001
000000 00011 00001 00010 00000 100001
r2 = r1 + r3

000000 sssss ttttt ddddd ----- 100001
000000 00010 00010 00100 00000 100001
r4 = r2 + r2

	resultado esperado:
	r2 = 1 + 3 = 4
	r4 = 4 + 4 = 8

611021
422021
----------------------------------------------

test cortocircuito 2
	prueba cortocircuito con instruccion i+2

000000 sssss ttttt ddddd ----- 100011
000000 01000 00010 00001 00000 100011
r1 = r8 - r2

001101 sssss ttttt CCCCCCCCCCCCCCCC
001101 00111 00111 0000000000000000
r7 = r7 or FFFF //nop

000000 sssss ttttt ddddd ----- 100011
000000 00001 00011 00100 00000 100011
r4 = r1 - r3

	resultado esperado:
	r1 = 8 - 2 = 6
	r7 = r7
	r4 = 6 - 3 = 3

1020823
34E70000
232023
----------------------------------------------

test store y load
	prueba guardar registro en memoria y cargar el valor en otro registro

101011 sssss ttttt CCCCCCCCCCCCCCCC
101011 00001 00101 0000000000000001
[r1 + 1] = r5

100011 sssss ttttt CCCCCCCCCCCCCCCC
100011 00001 00011 0000000000000001
r3 = [r1 + 1]

	resultado esperado:
	[2] = 5
	r3 = 5

AC250001
8C230001

----------------------------------------------

test escribir registro antes de leer
	prueba que una instruccion lea el valor actualizado de un registro, y no el viejo

000000 sssss ttttt ddddd ----- 100001
000000 00001 00010 00100 00000 100001
r4 = r1 + r2

001101 sssss ttttt CCCCCCCCCCCCCCCC
001101 00111 00111 0000000000000000
r7 = r7 or FFFF //nop

001101 sssss ttttt CCCCCCCCCCCCCCCC
001101 00111 00111 0000000000000000
r7 = r7 or FFFF //nop

000000 sssss ttttt ddddd ----- 100001
000000 00100 00010 00011 00000 100001
r3 = r4 + r2

	resultado esperado:
	r4 = 1 + 2 = 3
	r3 = 3 + 2 = 5

222021
34E70000
34E70000
821821

----------------------------------------------

test instrucciones 
	prueba el funcionamiento de cada instruccion independientemente

000000 ----- ttttt ddddd SSSSS 000000
000000 00000 00010 00001 00011 000000
r1 = r2 << 3 = 16

208C0

000000 ----- ttttt ddddd SSSSS 000010
000000 00000 01001 00100 00010 000010
r4 = r9 >> 2 = 2

92082

000000 ----- ttttt ddddd SSSSS 000011
000000 00000 01001 00100 00010 000011
r4 = r9 >>> 2 = 2 (signado)

92083

----------------------------------------------

test cortocircuito 3
	instrucciones del libro teorico pagina C18

000000 sssss ttttt ddddd ----- 100001
000000 00010 00011 00001 00000 100001

000000 sssss ttttt ddddd ----- 100011
000000 00001 00101 00100 00000 100011

000000 sssss ttttt ddddd ----- 100100
000000 00001 00111 00110 00000 100100

000000 sssss ttttt ddddd ----- 100101
000000 00001 01001 01000 00000 100101

000000 sssss ttttt ddddd ----- 100110
000000 00001 01011 01010 00000 100110

r1 = r2 + r3
r4 = r1 - r5
r6 = r1 & r7
r8 = r1 | r9
r10 = r1 ^ r11

	resultado esperado:
	r1 = 5
	r4 = 0
	r6 = 5
	r8 = 13 (D)
	r10 = 14 (E)

430821
252023
273024
294025
2B5026

----------------------------------------------

test cortocircuito 4
	instrucciones del libro teorico pagina C19

000000 sssss ttttt ddddd ----- 100001
000000 00010 00011 00001 00000 100001

100011 sssss ttttt CCCCCCCCCCCCCCCC
100011 00001 00100 0000000000000000

r1 = r2 + r3
r4 = [r1]
[r1 + 4] = r4 //este store no funciona porque no hay forwarding en etapa 4

	resultado esperado:
	r1 = 5
	r4 = 5

430821
8C240000

-----------------------------------------

test load byte

	Carga en r2 el contenido de la posicion de memoria [r0 + 1]

100000 sssss ttttt CCCCCCCCCCCCCCCC
100000 00000 00010 0000000000000001

80020001

-----------------------------------------

test load byte unsigned

	Carga en r2 el contenido de la posicion de memoria [r0 + 1]

100000 sssss ttttt CCCCCCCCCCCCCCCC
100100 00000 00010 0000000000000001

90020001

------------------------------------------
store byte 

Carga en la posicion de memoria [r2 + 1] el primer byte(con signo) del registro 1

101000 sssss ttttt CCCCCCCCCCCCCCCC
101000 00010 00001 0000000000000001

A0410001

------------------------------------------
store half word

Carga en la posicion de memoria [r1 + 1] media palabra(con signo) del registro 0

101001 sssss ttttt CCCCCCCCCCCCCCCC
101001 00001 00000 0000000000000001

A4200001

------------------------------------------

test hazard detection

100011 sssss ttttt CCCCCCCCCCCCCCCC
100011 00000 00010 0000000000000001
r2 = [r0 + 1]

000000 sssss ttttt ddddd ----- 100001
000000 00010 00011 00001 00000 100001
r1 = r2 + r3

	resultado esperado:
	r2 = 1
	r1 = 1 + 3 = 4

8C020001
430821

------------------------------------------

test hazard detection 2

100011 sssss ttttt CCCCCCCCCCCCCCCC
100011 00000 00010 0000000000000001
r2 = [r0 + 1]

000000 sssss ttttt ddddd ----- 100100
000000 00010 00101 00100 00000 100100
r4 = r2 & r5

000000 sssss ttttt ddddd ----- 100101
000000 00010 00110 00011 00000 100101
r3 = r2 | r6

000000 sssss ttttt ddddd ----- 100001
000000 00010 00011 00001 00000 100001
r1 = r2 + r3

	resultado esperado:
	r2 = 1
	r4 = r2 & r5 = 1
	r3 = r2 | r6 = 	
	r1 = r2 + r3 = 8

8C020001
452024
461825
430821

------------------------------------------

test branch on equal

000100 sssss ttttt CCCCCCCCCCCCCCCC
000100 00101 00101 0000000000000010

000000 sssss ttttt ddddd ----- 100100
000000 00010 00101 00100 00000 100100

000000 sssss ttttt ddddd ----- 100101
000000 00010 00110 00011 00000 100101

000000 sssss ttttt ddddd ----- 100001
000000 00010 00011 00001 00000 100001

	resultado esperado:
	branch 
	r4 = r2 & r5 = 1
	r3 = r2 | r6 = 	
	r1 = r2 + r3 = 8

10A50004
452024
461825
430821
252023
273024
294025
2B5026

------------------------------------------

test set on less than

000000 00010 00010 00011 00000 101010

42182A

------------------------------------------

test set on less than inmmidiate

001010 00010 00011 0000000000000010

------------------------------------------

test jump register

000000 00000 00000 00000 00000 001000

------------------------------------------

test jump and link register

000000 00011 00000 00100 00000 001001

602009

------------------------------------------

test jump and link

000011 00000000000000000000000011

C000003
